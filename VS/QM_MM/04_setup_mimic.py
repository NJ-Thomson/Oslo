#!/usr/bin/env python3
"""
04_setup_mimic.py - Set Up GROMACS/ORCA/MiMiC Input Files

Generates all input files needed for QM/MM umbrella sampling:
- GROMACS .mdp files with MiMiC and pull code settings
- ORCA input files for QM calculations
- Index files for QM region and pull groups
- Job submission scripts

Usage:
    python 04_setup_mimic.py --config config.yaml [--method r2SCAN-3c]

Output per window:
    window_XXX/
        ├── mimic.mdp           - GROMACS MDP with MiMiC settings
        ├── pull.mdp            - Pull code settings (included)
        ├── orca_qmmm.inp       - ORCA input file
        ├── qm_atoms.ndx        - Index file for QM region
        ├── run_mimic.sh        - Execution script
        └── submit_slurm.sh     - SLURM submission script
"""

import argparse
import json
import shutil
from pathlib import Path
from typing import Dict, List, Optional

import yaml

try:
    import MDAnalysis as mda
    HAS_MDA = True
except ImportError:
    HAS_MDA = False


def load_config(config_path: Path) -> dict:
    with open(config_path) as f:
        return yaml.safe_load(f)


# =============================================================================
# ORCA Input Generation
# =============================================================================

def generate_orca_input(
    qm_region: Dict,
    config: dict,
    output_path: Path,
    window_info: Dict
) -> str:
    """Generate ORCA input file for QM/MM calculation."""
    
    qm_cfg = config['qm']
    method = qm_cfg.get('method', 'r2SCAN-3c')
    charge = qm_region.get('qm_charge', 0)
    mult = qm_cfg.get('multiplicity', 1)
    maxcore = qm_cfg.get('maxcore', 4000)
    
    # Build method line
    if method in ['r2SCAN-3c', 'B97-3c', 'PBEh-3c']:
        # Composite methods
        method_line = f"! {method} TightSCF"
    else:
        # Explicit functional/basis
        functional = qm_cfg.get('functional', 'B3LYP')
        basis = qm_cfg.get('basis_set', 'def2-SVP')
        dispersion = qm_cfg.get('dispersion', 'D3BJ')
        
        method_line = f"! {functional} {basis}"
        if dispersion:
            method_line += f" {dispersion}"
        method_line += " TightSCF"
        
        # Add RI if auxiliary basis specified
        aux_basis = qm_cfg.get('auxiliary_basis')
        if aux_basis:
            method_line += f" RIJCOSX {aux_basis}"
    
    # SCF settings
    scf_cfg = qm_cfg.get('scf', {})
    max_iter = scf_cfg.get('max_iter', 200)
    
    # Grid settings
    grid = qm_cfg.get('grid', 'DefGrid2')
    
    orca_input = f"""# ORCA input for QM/MM calculation
# System: {output_path.parent.parent.parent.name}
# Window: {window_info.get('window_index', 'N/A')} (r = {window_info.get('target_distance_A', 0):.2f} Å)
# Generated by QM_MM workflow

{method_line}
%pal nprocs {{NPROCS}} end
%maxcore {maxcore}

%scf
    MaxIter {max_iter}
    DIISMaxEq {scf_cfg.get('diis_max_eq', 7)}
end

# Point charges from MM region (written by MiMiC)
%pointcharges "charges.pc"

# QM region coordinates (updated by MiMiC each step)
* xyzfile {charge} {mult} qm_region.xyz
"""
    
    with open(output_path, 'w') as f:
        f.write(orca_input)
    
    return orca_input


# =============================================================================
# GROMACS MDP Generation
# =============================================================================

def generate_mimic_mdp(
    config: dict,
    window_info: Dict,
    qm_region: Dict,
    output_path: Path,
    stage: str = 'production'
) -> str:
    """Generate GROMACS MDP file with MiMiC and pull settings."""
    
    sim_cfg = config['simulation']
    mm_cfg = config['mm']
    mimic_cfg = config['mimic']
    umb_cfg = config['umbrella_sampling']
    
    # Determine step count
    if stage == 'equilibration':
        nsteps = sim_cfg['equilibration']['nsteps']
    else:
        nsteps = sim_cfg['production']['nsteps']
    
    dt = sim_cfg['dt']
    
    # Pull settings
    target_dist = window_info['target_distance_nm']
    force_k = umb_cfg['restraint']['force_constant']
    
    # Check for adaptive force constant
    adaptive = umb_cfg.get('adaptive', {})
    if adaptive.get('enabled', False):
        ts_region = adaptive.get('ts_region_nm', [0.23, 0.32])
        if ts_region[0] <= target_dist <= ts_region[1]:
            force_k = adaptive.get('ts_force_constant', force_k)
    
    mdp_content = f"""; GROMACS MDP for QM/MM with MiMiC
; Window {window_info.get('window_index', 'N/A')}: r = {target_dist:.3f} nm
; Stage: {stage}

; =============================================================================
; Run Control
; =============================================================================
integrator               = md
tinit                    = 0
dt                       = {dt}
nsteps                   = {nsteps}
comm-mode                = Linear
nstcomm                  = 100

; =============================================================================
; Output Control
; =============================================================================
nstxout                  = {sim_cfg.get('nstxout', 0)}
nstvout                  = {sim_cfg.get('nstvout', 0)}
nstfout                  = {sim_cfg.get('nstfout', 0)}
nstlog                   = {sim_cfg.get('nstlog', 100)}
nstenergy                = {sim_cfg.get('nstenergy', 100)}
nstxout-compressed       = {sim_cfg.get('nstxout_compressed', 100)}
compressed-x-precision   = 1000

; =============================================================================
; Neighbour Searching
; =============================================================================
cutoff-scheme            = Verlet
nstlist                  = {sim_cfg.get('nstlist', 10)}
ns_type                  = grid
pbc                      = xyz
verlet-buffer-tolerance  = 0.005

; =============================================================================
; Electrostatics
; =============================================================================
coulombtype              = {mm_cfg.get('coulombtype', 'PME')}
rcoulomb                 = {mm_cfg.get('rcoulomb', 1.2)}
pme_order                = {mm_cfg.get('pme_order', 4)}
fourierspacing           = {mm_cfg.get('fourierspacing', 0.12)}

; =============================================================================
; VdW
; =============================================================================
vdwtype                  = Cut-off
rvdw                     = {mm_cfg.get('rvdw', 1.2)}
DispCorr                 = EnerPres

; =============================================================================
; Temperature Coupling
; =============================================================================
tcoupl                   = {sim_cfg.get('tcoupl', 'V-rescale')}
tc-grps                  = System
tau_t                    = {sim_cfg.get('tau_t', 0.1)}
ref_t                    = {sim_cfg.get('ref_t', 300)}

; =============================================================================
; Pressure Coupling
; =============================================================================
pcoupl                   = {sim_cfg.get('pcoupl', 'Parrinello-Rahman')}
pcoupltype               = {sim_cfg.get('pcoupltype', 'isotropic')}
tau_p                    = {sim_cfg.get('tau_p', 2.0)}
ref_p                    = {sim_cfg.get('ref_p', 1.0)}
compressibility          = {sim_cfg.get('compressibility', 4.5e-5)}
refcoord_scaling         = com

; =============================================================================
; Constraints
; =============================================================================
constraints              = {mm_cfg.get('constraints', 'h-bonds')}
constraint_algorithm     = {mm_cfg.get('constraint_algorithm', 'LINCS')}
lincs_iter               = 1
lincs_order              = 4

; =============================================================================
; MiMiC QM/MM Settings
; =============================================================================
QMMM                     = yes
QMMM-grps                = QM_atoms

; =============================================================================
; Pull Code (Umbrella Sampling)
; =============================================================================
pull                     = yes
pull-nstxout             = 10
pull-nstfout             = 10
pull-ngroups             = 2
pull-ncoords             = 1

; Pull groups (defined in index file)
pull-group1-name         = QM_SG
pull-group2-name         = QM_C1

; Pull coordinate: S-C distance
pull-coord1-type         = umbrella
pull-coord1-geometry     = distance
pull-coord1-dim          = Y Y Y
pull-coord1-groups       = 1 2
pull-coord1-init         = {target_dist:.4f}
pull-coord1-rate         = 0.0
pull-coord1-k            = {force_k:.1f}
pull-coord1-start        = no

; =============================================================================
; Generate velocities (only for equilibration)
; =============================================================================
"""
    
    if stage == 'equilibration':
        mdp_content += f"""gen_vel                  = yes
gen_temp                 = {sim_cfg.get('ref_t', 300)}
gen_seed                 = -1
"""
    else:
        mdp_content += """gen_vel                  = no
continuation             = yes
"""
    
    with open(output_path, 'w') as f:
        f.write(mdp_content)
    
    return mdp_content


# =============================================================================
# Index File Generation
# =============================================================================

def generate_qm_index(
    qm_region: Dict,
    window_info: Dict,
    output_path: Path
) -> None:
    """Generate GROMACS index file with QM atoms and pull groups."""
    
    qm_indices = qm_region['qm_indices_1based']  # 1-based for GROMACS
    sg_idx = window_info['sg_index_1based']
    c1_idx = window_info['c1_index_1based']
    
    with open(output_path, 'w') as f:
        # QM atoms group
        f.write("[ QM_atoms ]\n")
        for i, idx in enumerate(qm_indices):
            f.write(f"{idx:6d}")
            if (i + 1) % 15 == 0:
                f.write("\n")
        f.write("\n\n")
        
        # Pull groups
        f.write("[ QM_SG ]\n")
        f.write(f"{sg_idx}\n\n")
        
        f.write("[ QM_C1 ]\n")
        f.write(f"{c1_idx}\n")


# =============================================================================
# Job Scripts
# =============================================================================

def generate_run_script(
    config: dict,
    window_dir: Path,
    window_info: Dict
) -> None:
    """Generate shell script to run MiMiC simulation."""
    
    software = config.get('software', {})
    gmx_mimic = software.get('gromacs_mimic') or 'gmx_mimic'
    orca_path = software.get('orca') or 'orca'
    
    resources = config['resources']
    qm_cpus = resources['qm']['ncpus']
    mm_cpus = resources['mm']['ncpus']
    
    script = f"""#!/bin/bash
# Run MiMiC QM/MM simulation
# Window {window_info['window_index']}: r = {window_info['target_distance_nm']:.3f} nm

set -e

# Configuration
GMX_MIMIC="{gmx_mimic}"
ORCA="{orca_path}"
NPROCS_QM={qm_cpus}
NPROCS_MM={mm_cpus}

WINDOW_DIR="$(cd "$(dirname "$0")" && pwd)"
cd "$WINDOW_DIR"

echo "=========================================="
echo "MiMiC QM/MM - Window {window_info['window_index']}"
echo "Target distance: {window_info['target_distance_nm']:.3f} nm"
echo "=========================================="

# Step 1: Prepare TPR file
echo "[1/4] Preparing GROMACS TPR..."
$GMX_MIMIC grompp \\
    -f mimic_equil.mdp \\
    -c conf.gro \\
    -p ../topology/topol.top \\
    -n combined.ndx \\
    -o equil.tpr \\
    -maxwarn 2

# Step 2: Run equilibration with MiMiC
echo "[2/4] Running equilibration..."
# Start ORCA in background
sed "s/{{NPROCS}}/$NPROCS_QM/g" orca_qmmm.inp > orca_run.inp
$ORCA orca_run.inp > orca_equil.log 2>&1 &
ORCA_PID=$!

# Run GROMACS with MiMiC
$GMX_MIMIC mdrun \\
    -s equil.tpr \\
    -deffnm equil \\
    -ntomp $NPROCS_MM \\
    -mimic

wait $ORCA_PID

# Step 3: Prepare production TPR
echo "[3/4] Preparing production TPR..."
$GMX_MIMIC grompp \\
    -f mimic_prod.mdp \\
    -c equil.gro \\
    -t equil.cpt \\
    -p ../topology/topol.top \\
    -n combined.ndx \\
    -o prod.tpr \\
    -maxwarn 2

# Step 4: Run production
echo "[4/4] Running production..."
$ORCA orca_run.inp > orca_prod.log 2>&1 &
ORCA_PID=$!

$GMX_MIMIC mdrun \\
    -s prod.tpr \\
    -deffnm prod \\
    -ntomp $NPROCS_MM \\
    -mimic

wait $ORCA_PID

echo "=========================================="
echo "Window {window_info['window_index']} complete!"
echo "=========================================="
"""
    
    script_path = window_dir / 'run_mimic.sh'
    with open(script_path, 'w') as f:
        f.write(script)
    script_path.chmod(0o755)


def generate_slurm_script(
    config: dict,
    window_dir: Path,
    window_info: Dict,
    system_info: Dict
) -> None:
    """Generate SLURM submission script."""
    
    resources = config['resources']
    hpc = resources.get('hpc', {})
    
    total_cpus = resources['qm']['ncpus'] + resources['mm']['ncpus']
    mem_gb = resources['qm']['memory_gb']
    walltime = resources['walltime_hours']
    
    partition = hpc.get('partition', 'normal')
    account = hpc.get('account', '')
    modules = hpc.get('modules', [])
    
    job_name = f"qmmm_{system_info['inhibitor']}_{system_info['warhead']}_w{window_info['window_index']:03d}"
    
    script = f"""#!/bin/bash
#SBATCH --job-name={job_name}
#SBATCH --output=slurm_%j.out
#SBATCH --error=slurm_%j.err
#SBATCH --ntasks=1
#SBATCH --cpus-per-task={total_cpus}
#SBATCH --mem={mem_gb}G
#SBATCH --time={walltime}:00:00
#SBATCH --partition={partition}
"""
    
    if account:
        script += f"#SBATCH --account={account}\n"
    
    script += "\n# Load modules\n"
    for mod in modules:
        script += f"module load {mod}\n"
    
    script += """
# Set OMP threads for ORCA
export OMP_NUM_THREADS=$SLURM_CPUS_PER_TASK

# Run the simulation
./run_mimic.sh
"""
    
    script_path = window_dir / 'submit_slurm.sh'
    with open(script_path, 'w') as f:
        f.write(script)
    script_path.chmod(0o755)


# =============================================================================
# Main Setup Function
# =============================================================================

def setup_window(
    window_dir: Path,
    system_dir: Path,
    config: dict
) -> bool:
    """Set up all input files for a single window."""
    
    # Load window info
    with open(window_dir / 'window_info.json') as f:
        window_info = json.load(f)
    
    # Load system info
    with open(system_dir / 'system_info.json') as f:
        system_info = json.load(f)
    
    # Load QM region
    with open(system_dir / 'qm_region.json') as f:
        qm_region = json.load(f)
    
    # Generate ORCA input
    generate_orca_input(
        qm_region, config,
        window_dir / 'orca_qmmm.inp',
        window_info
    )
    
    # Generate MDP files
    generate_mimic_mdp(
        config, window_info, qm_region,
        window_dir / 'mimic_equil.mdp',
        stage='equilibration'
    )
    
    generate_mimic_mdp(
        config, window_info, qm_region,
        window_dir / 'mimic_prod.mdp',
        stage='production'
    )
    
    # Generate index file
    generate_qm_index(
        qm_region, window_info,
        window_dir / 'qm_atoms.ndx'
    )
    
    # Combine with pull index
    with open(window_dir / 'combined.ndx', 'w') as out_f:
        with open(window_dir / 'qm_atoms.ndx') as qm_f:
            out_f.write(qm_f.read())
        with open(window_dir / 'pull.ndx') as pull_f:
            out_f.write(pull_f.read())
    
    # Generate run scripts
    generate_run_script(config, window_dir, window_info)
    generate_slurm_script(config, window_dir, window_info, system_info)
    
    return True


def process_system(system_dir: Path, config: dict) -> bool:
    """Set up MiMiC inputs for all windows of a system."""
    
    # Load system info
    with open(system_dir / 'system_info.json') as f:
        system_info = json.load(f)
    
    print(f"  Processing: {system_info['receptor']}/{system_info['inhibitor']}/{system_info['warhead']}")
    
    # Check for required files
    if not (system_dir / 'qm_region.json').exists():
        print("    ERROR: qm_region.json not found. Run step 02 first.")
        return False
    
    windows_dir = system_dir / 'windows'
    if not windows_dir.exists():
        print("    ERROR: windows/ not found. Run step 03 first.")
        return False
    
    # Copy topology to accessible location
    topology_src = system_dir / 'topology'
    
    # Process each window
    window_dirs = sorted(windows_dir.glob('window_*'))
    success_count = 0
    
    for window_dir in window_dirs:
        try:
            if setup_window(window_dir, system_dir, config):
                success_count += 1
        except Exception as e:
            print(f"    ERROR in {window_dir.name}: {e}")
    
    print(f"    ✓ Set up {success_count}/{len(window_dirs)} windows")
    
    return success_count == len(window_dirs)


def main():
    parser = argparse.ArgumentParser(description="Set up GROMACS/ORCA/MiMiC inputs")
    parser.add_argument('--config', type=Path, default=Path(__file__).parent / 'config.yaml')
    parser.add_argument('--method', type=str, default=None,
                       help='QM method (e.g., r2SCAN-3c, B3LYP)')
    parser.add_argument('--receptors', nargs='+', default=None)
    parser.add_argument('--inhibitors', nargs='+', default=None)
    parser.add_argument('--warheads', nargs='+', default=None)
    args = parser.parse_args()
    
    config = load_config(args.config)
    base_dir = args.config.parent
    
    # Override method if specified
    if args.method:
        config['qm']['method'] = args.method
    
    output_dir = Path(config['paths']['output_dir'])
    if not output_dir.is_absolute():
        output_dir = (base_dir / output_dir).resolve()
    
    print("=" * 60)
    print("Step 4: Set Up GROMACS/ORCA/MiMiC Inputs")
    print("=" * 60)
    print(f"QM Method: {config['qm']['method']}")
    print()
    
    # Get system lists
    receptors = args.receptors or list(config['systems']['receptors'].keys())
    inhibitors = args.inhibitors or config['systems']['inhibitors']
    warheads = args.warheads or list(config['systems']['warheads'].keys())
    
    success_count = 0
    total_count = 0
    
    for receptor in receptors:
        for inhibitor in inhibitors:
            for warhead in warheads:
                system_dir = output_dir / receptor / inhibitor / warhead
                if system_dir.exists() and (system_dir / 'system_info.json').exists():
                    total_count += 1
                    if process_system(system_dir, config):
                        success_count += 1
    
    print()
    print(f"Set up MiMiC inputs for {success_count}/{total_count} systems")
    
    return success_count == total_count


if __name__ == '__main__':
    import sys
    sys.exit(0 if main() else 1)
